
1. 给定两个排序后的数组a和b, 其中a的未端有足够的空间来存b,,编写一个方法，将b合并入a并排序. 
     解决方案:  从数组的最后开始比较，将最大的元素放到数组a的最后

2. 编写一个方法 ，对字符串数组进行排序，将所有变位词排在相邻的两个位置. 

3. 如果你有一个20G的文件，每一行一个字符串，说明你将如何对这个文件进行排序. 
        解决方案: 外部排序法，在内存外部将多个小文件排好序，再合并. 
        
        
        
4. 有个排序后的字符串数组， 中间有很多空串，编写一个方法，找出给定字符串的位置. 
   解决方案: 改进二分法查找. ,  二分法查找中最重要的就是中间数据，如果中间数为空，则将中间数换到离它最近的非空字符串的位置 。 
   
5. 随机发牌. 有10000张牌,随机发出一张，要使得随机发出的牌不重复，而且时间，空间复杂度要恒定。如何实现?


   =>  [1,2,3,4,5,6,7,8.....10000];
   
6. 字符串压缩算法:利用字符重复出现的次数，实现基本的字符串压缩算法. 比如:  aabbbcccceeeee 变为 a2b3c4e5,
若压缩后的字符串没有变短，则返回原来的字符串（这里指是 abcdef,这样就会变为a1b1c1d1e1f1). 

7. 将一个字符数组中所有的空格全部替换成为  "%20",假设这个字符数组中有足够的空间存放新增字符. 
   String s="ab c";    s.toCharArray();

   char[] chs=new char[]{'a','b',' ','c',' ',' ',' ',' ' };
   int length=4;
   
   
   =>   {'a','b','%','2','0','c',' ',' ' };
   
 8. 确定一个字符串的所有字符是否全都不同.
 
 9. 有一个已经排序的数组（升序），数组中可能有正数、负数或0，求数组中元素的绝对值最小的数，要求，不能用顺序比较的方法（复杂度需要小于O（n）），可以使用任何语言实现

例如，数组{-20，-13，-4, 6, 77,200} ，绝对值最小的是-4。



初步的解决思路是：

    1.数组中的元素全为正，取最左边的数字；

    2.数组中的元素全为负，取最右边的数字的绝对值；

    3.数组中有正数有负数，就用二分法查找，判断中间元素的符号

       a)中间元素为正，继续判断中间元素前面一个元素的符号

       b)中间元素为负，判断中间元素后一个元素的符号

       c)中间元素为零，令其等于结果值返回

下面是根据上面的想法的代码实现，应该还会有漏洞
 
